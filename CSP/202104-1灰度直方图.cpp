/*问题描述：一幅长宽分别为n个像素和m个像素的灰度图像可以表示为一个n×m大小的矩阵A。
其中每个元素Aij（0≤i<n、0≤j<m）是一个[0,L)范围内的整数，表示对应位置像素的灰度值。
具体来说，一个8比特的灰度图像中每个像素的灰度范围是[0,128)。
一副灰度图像的灰度统计直方图（以下简称“直方图”）可以表示为一个长度为L的数组h，
其中h[x]（0≤x<L）表示该图像中灰度值为x的像素个数。显然，h[0]到h[L−1]的总和应等于图像中的像素总数n⋅m。

已知一副图像的灰度矩阵A，试计算其灰度直方图h[0],h[1],⋯,h[L−1]。

输入格式：
输入共n+1行。输入的第一行包含三个用空格分隔的正整数n、m和L，含义如前文所述。
第二到第n+1行输入矩阵A。
第i+2（0≤i<n）行包含用空格分隔的m个整数，依次为Ai0,Ai1,⋯,Ai(m−1)。

输出格式：
输出仅一行，包含用空格分隔的L个整数h[0],h[1],⋯,h[L−1]，表示输入图像的灰度直方图。

样例输入：
4 4 16
0 1 2 3
4 5 6 7
8 9 10 11
12 13 14 15
样例输出：
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
样例输入：
7 11 8
0 7 0 0 0 7 0 0 7 7 0
7 0 7 0 7 0 7 0 7 0 7
7 0 0 0 7 0 0 0 7 0 7
7 0 0 0 0 7 0 0 7 7 0
7 0 0 0 0 0 7 0 7 0 0
7 0 7 0 7 0 7 0 7 0 0
0 7 0 0 0 7 0 0 7 0 0
样例输出：
48 0 0 0 0 0 0 29
评测用例规模与约定：
全部的测试数据满足0<n,m≤500且4≤L≤256。
*/

#include <cstdlib>
#include <cstdio>

int main()
{
    int N, M, L;
    scanf("%d %d %d", &N, &M, &L);

    //动态创建n*m矩阵
    int **matrix = (int **)malloc(sizeof(*matrix) * N);
    for (int i = 0; i < N; i++)
        matrix[i] = (int *)malloc(sizeof(int) * M);

    //动态创建灰度直方图
    int *list = (int *)malloc(sizeof(int) * L);

    for (int i = 0; i < L; i++)
        list[i] = 0;

    for (int n = 0; n < N; n++)
    {
        for (int m = 0; m < M; m++)
        {
            int elem = 0;
            scanf("%d", &elem);
            getchar();
            //忽略输入的空格和回车
            matrix[n][m] = elem;
        }
    }

    for (int n = 0; n < N; n++)
    {
        for (int m = 0; m < M; m++)
            list[matrix[n][m]]++;
    }

    for (int i = 0; i < L; i++)
        printf("%d ", list[i]);

        return 0;
}